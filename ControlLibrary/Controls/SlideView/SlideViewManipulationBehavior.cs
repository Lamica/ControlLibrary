using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ControlLibrary.Primitives.Gestures;
using Windows.Foundation;
using Windows.UI.Xaml;
using Windows.UI.Xaml.Controls;

namespace ControlLibrary
{
    /// <summary>
    /// Handles the user input and provides the navigation for a <see cref="RadSlideView"/> instance.
    /// </summary>
    public abstract class SlideViewManipulationBehavior : DependencyObject
    {
        private SlideView view;
        private bool isEnabled = true;
        private bool isStretching;
        private bool isManipulating;
        private bool gestureHandled;
        private Point offset;
        private SlideViewAnimationState animationState;

        /// <summary>
        /// Gets the <see cref="SlideViewPanel"/> instance this behavior is attached to.
        /// </summary>
        public SlideViewPanel Panel
        {
            get
            {
                if (this.view == null)
                {
                    return null;
                }

                return this.view.Panel;
            }
        }

        /// <summary>
        /// Gets the <see cref="RadSlideView"/> instance this behavior is attached to.
        /// </summary>
        public SlideView View
        {
            get
            {
                return this.view;
            }
        }

        /// <summary>
        /// Gets the current <see cref="SlideViewAnimationState"/> value of the behavior.
        /// </summary>
        public SlideViewAnimationState AnimationState
        {
            get
            {
                return this.animationState;
            }
            internal set
            {
                this.animationState = value;
            }
        }

        /// <summary>
        /// Determines whether the behavior is enabled.
        /// </summary>
        public bool IsEnabled
        {
            get
            {
                if (!this.isEnabled)
                {
                    return false;
                }

                return this.View != null && this.View.ListSource.Count > 1;
            }
            set
            {
                this.isEnabled = value;
                if (this.isManipulating && !this.isEnabled)
                {
                    this.CancelManipulation();
                }
            }
        }

        /// <summary>
        /// Determines whether a gesture has been handled within a GestureStart/GestureComplete block.
        /// </summary>
        protected bool GestureHandled
        {
            get
            {
                return this.gestureHandled;
            }
        }

        /// <summary>
        /// Determines whether the View is currently being stretched. That is the maximum or minimum drag offset is reached and the View is being scaled to perform the so called "Bounce" effect.
        /// </summary>
        protected bool IsStretching
        {
            get
            {
                return this.isStretching;
            }
        }

        /// <summary>
        /// Determines whether the behavior is currently within a Manipulationstarted/ManipulationCompleted block.
        /// </summary>
        protected bool IsManipulating
        {
            get
            {
                return this.isManipulating;
            }
        }

        /// <summary>
        /// Gets the current offset, generated by a Pan gesture.
        /// </summary>
        protected Point Offset
        {
            get
            {
                return this.offset;
            }
        }

        /// <summary>
        /// Gets the current signifficant offset (along the X or the Y axis), depending on the Orientation value of the owning <see cref="RadSlideView"/> instance.
        /// </summary>
        protected double OffsetLength
        {
            get
            {
                if (this.View == null)
                {
                    return 0;
                }

                return this.View.Orientation == Orientation.Horizontal ? this.offset.X : this.offset.Y;
            }
        }

        internal virtual void MoveToNextItem()
        {
        }

        internal virtual void MoveToPreviousItem()
        {
        }

        internal virtual void ResetCache()
        {
        }

        internal void Attach(SlideView view)
        {
            this.view = view;
            this.OnAttached();
        }

        internal void Detach()
        {
            if (this.view == null)
            {
                return;
            }

            SlideView oldView = this.view;
            this.view = null;
            this.OnDetached(oldView);
        }

        internal virtual void ResetTransform()
        {
        }

        /// <summary>
        /// Responds to the current gesture.
        /// </summary>
        /// <param name="gesture"></param>
        internal void HandleGesture(Gesture gesture)
        {
            if (!this.CanHandleGesture(gesture))
            {
                return;
            }

            switch (gesture.GestureType)
            {
                case KnownGesture.Pan:
                    this.HandlePan(gesture as PanGesture);
                    break;
                case KnownGesture.Flick:
                    this.HandleFlick(gesture as FlickGesture);
                    break;
                default:
                    return;
            }

            this.gestureHandled = gesture.Handled = true;
        }

        internal void HandleGestureStarted()
        {
            this.gestureHandled = false;
            this.isManipulating = true;
            this.isStretching = false;
            this.offset = new Point(0, 0);
            this.OnGestureStarted();
        }

        internal void HandleGestureCompleted(Gesture gesture)
        {
            if (this.IsStretching)
            {
                this.ResetStretch();
            }
            else if (gesture != null)
            {
                //// gesture may be null if we have not received a ManipulationDelta event
                if (!this.CanHandleGesture(gesture))
                {
                    if (this.gestureHandled)
                    {
                        // we have a Pan gesture handled, complete it
                        this.OnGestureCompleted(new PanGesture());
                    }
                }
                else
                {
                    this.OnGestureCompleted(gesture);
                }
            }

            if (gesture != null)
            {
                gesture.Handled = this.gestureHandled;
            }

            this.isManipulating = false;
            this.isStretching = false;
            this.offset = new Point(0, 0);
        }

        /// <summary>
        /// Called by the owning <see cref="RadSlideView"/> instance when the control is comletely loaded on the visual scene.
        /// </summary>
        protected internal virtual void OnLoaded()
        {
        }

        /// <summary>
        /// Occurs upon a valid <see cref="PanGesture"/>.
        /// </summary>
        /// <param name="gesture"></param>
        protected virtual void OnPan(PanGesture gesture)
        {
        }

        /// <summary>
        /// Occurs upon a valid <see cref="PanGesture"/> when the end (or beginning) of the sequence is reached and navigation to next/previous item may not be completed.
        /// </summary>
        /// <param name="panGesture"></param>
        protected virtual void OnPanStretch(PanGesture panGesture)
        {
        }

        /// <summary>
        /// Occurs upon a valid <see cref="FlickGesture"/>.
        /// </summary>
        /// <param name="gesture"></param>
        protected virtual void OnFlick(FlickGesture gesture)
        {
        }

        /// <summary>
        /// Determines whether all the condinitions, needed to process a gesture, are met.
        /// </summary>
        /// <param name="gesture">The gesture to examine.</param>
        /// <returns></returns>
        protected virtual bool CanHandleGesture(Gesture gesture)
        {
            if (!this.IsEnabled)
            {
                return false;
            }

            if (this.Panel.WaitingForLayout)
            {
                return false;
            }

            if (gesture.GestureType == KnownGesture.Flick)
            {
                DragDirection flickDirection = GestureBehavior.GetDragDirection((gesture as FlickGesture).Velocity);
                if (this.View.Orientation == Orientation.Horizontal)
                {
                    return flickDirection == DragDirection.Horizontal;
                }

                return flickDirection == DragDirection.Vertical;
            }

            return gesture.GestureType == KnownGesture.Pan;
        }

        /// <summary>
        /// Occurs upon the ManipulationStarted event, raised by the owning <see cref="RadSlideView"/> instance.
        /// </summary>
        protected virtual void OnGestureStarted()
        {
        }

        /// <summary>
        /// Occurs upon a completion of a handled gesture.
        /// </summary>
        /// <param name="gesture"></param>
        protected virtual void OnGestureCompleted(Gesture gesture)
        {
        }

        /// <summary>
        /// Occurs when the behavior has been successfully attached to a valid <see cref="RadSlideView"/> instance.
        /// </summary>
        protected virtual void OnAttached()
        {
        }

        /// <summary>
        /// Occurs when the behavior has been detached from a previously attached <see cref="RadSlideView"/> instance.
        /// </summary>
        /// <param name="oldView"></param>
        protected virtual void OnDetached(SlideView oldView)
        {
        }

        /// <summary>
        /// Cancel any running manipulation.
        /// </summary>
        protected virtual void CancelManipulation()
        {
        }

        /// <summary>
        /// Resets the Stretch transformations (if any).
        /// </summary>
        protected virtual void ResetStretch()
        {
        }

        /// <summary>
        /// Checks whether the specified offset needs to be adjusted to not exceed the available for realization data.
        /// </summary>
        /// <param name="offset"></param>
        /// <returns></returns>
        private Point ClampOffset(Point offset)
        {
            if (this.View.ListSource.Count == 1)
            {
                // only one item, we need to bounce/stretch it
                return new Point(0, 0);
            }

            if (this.View.IsLoopingEnabled)
            {
                // looping is enabled, so no need to clamp the offset here
                return offset;
            }

            double length = this.View.Orientation == Orientation.Horizontal ? offset.X : offset.Y;
            if (length < 0)
            {
                // negative pan, check the previous item availability
                if (this.View.GetNextDataSourceItem() == null)
                {
                    return new Point(Math.Max(0, offset.X), Math.Max(0, offset.Y));
                }
            }
            else
            {
                // positive pan, check the previous item availability
                if (this.View.GetPreviousDataSourceItem() == null)
                {
                    return new Point(Math.Min(0, offset.X), Math.Min(0, offset.Y));
                }
            }

            return offset;
        }

        private void HandlePan(PanGesture panGesture)
        {
            if (this.animationState != SlideViewAnimationState.None)
            {
                return;
            }

            this.isStretching = false;

            Point translation = panGesture.CumulativeTranslation;
            this.offset = this.ClampOffset(translation);

            if (translation != this.offset)
            {
                this.isStretching = true;
                this.OnPanStretch(panGesture);
            }
            else
            {
                this.OnPan(panGesture);
            }
        }

        private void HandleFlick(FlickGesture flickGesture)
        {
            if (this.animationState != SlideViewAnimationState.None)
            {
                return;
            }

            if (this.isStretching)
            {
                this.ResetStretch();
                return;
            }

            this.OnFlick(flickGesture);
        }
    }
}
